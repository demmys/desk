Desk
==========
demmyによるJVM上で動作するHaskellライクな純粋関数型言語Deskのコンパイラ

##動作確認済み環境##
+ Intel Core i5
+ Mac OS X Lion(10.7.5)
+ gcc version 4.2.1 LLVM build
+ GNU Bison 2.3
+ flex 2.5.35
+ Java version 1.6.0_51

##使用方法##
`make`によって生成される`desk`がDeskコンパイラ本体です。  
DeskではInt型(32bit符号付き整数)以外をサポートしていないため、Hello Worldプログラムを走らせることはできませんが、
サンプルとして同梱されているコードをコンパイルすることで動作確認を行うことができます。  
DeskコンパイラはソースコードをJava言語と同じ`.class`ファイルへコンパイルします。そのため、Deskの実行にはJava仮想マシンが必要ですが、逆に言えば、Java仮想マシンが用意されている全ての環境でDeskによってコンパイルしたプログラムを実行することができます。  
Deskの実行はjavaコマンドを用いて以下のように行います。

```
$ desk Fibonacci.desk
$ java Sample 10
55
```

##言語仕様##
Deskでは以下の様な形で関数を定義していくことでプログラムを記述します。
```
<関数名>(<引数名>) = <式>;
```
mainという名前の関数が宣言された場合、その関数がプログラム実行時に最初に呼ばれる関数となります。  
その際、main関数の引数値はコマンドラインからの入力、返り値は標準出力への出力となります。  
引数をとらない関数を定義する場合、`( )`を省略することができます。
```
<引数をとらない関数名> = <式>;
```
特定の値を引数として渡した場合に特定の処理を行われるためにパターンマッチを利用することができます。
```
<関数名>(<マッチさせる数>) = <式>;
```
現時点で`<マッチさせる数>`は自然数でなければなりません。
また、式には加算`+`、減算`-`、乗算`*`、除算`/`、剰余算`%`及び優先度を上げる`(`、`)`を二項演算子として用いることができます。
減算演算子`-`を単項演算子として用いた場合は符号を逆転させる働きを持ちます。  
関数の呼び出しは以下のように行います。
```
<関数名>(<式>)
```
なお、Deskでは現時点で2つ以上の引数をとる関数を定義できません。

##中身##
+ `ファイル名` :  
ファイルの説明

###utils/###
+ `storage.h` :  
ストレージ方式を用いたメモリ管理のための構造体、関数プロトタイプの宣言ファイル

+ `storage.c` :  
ストレージ方式を用いたメモリ管理のための関数実装ファイル

+ `error.h` :  
エラーを表現するための列挙型定数、関数プロトタイプの宣言ファイル

+ `error.c` :  
エラーを実現するための関数、エラー文実装ファイル

###compile/###
+ `compiler.h` :  
Compiler構造体を中心とする、構文木生成のための構造体、列挙型定数、関数プロトタイプの宣言ファイル

+ `compiler.c` :  
Compiler構造体関係の関数実装、静的なコンパイラ型変数の宣言ファイル

+ `create.h` :  
構文解析中に使用するメソッドのプロトタイプ宣言ファイル

+ `create.c` :  
構文解析中に使用する構文に対応したオブジェクトを生成する関数の実装ファイル

+ `desk.l` :  
一応型や識別子も解析するlexファイル

+ `desk.y` :  
mainとその右辺の定数式のみ解析できるyaccファイル

###generate/###
+ `base.h` :  
クラスファイル内で用いられる識別子のtypedef宣言ファイル

+ `constant_pool.h` :  
ConstantInfo構造体を中心とする、コンスタントプールを実現するための構造体、列挙型定数、関数プロトタイプ宣言ファイル

+ `constant_pool.c` :  
ClassFile構造体内のコンスタントプールを実装するための関数定義ファイル

+ `attributes.h` :  
AttributeInfo構造体を中心とする、アトリビュートを実現するための構造体、列挙型定数、関数プロトタイプ宣言ファイル

+ `attributes.c` :  
ClassFile構造体やCodeアトリビュート内のアトリビュートを実装するための関数定義ファイル

+ `definition.h` :  
Definition構造体を中心とする、メソッド・フィールド・インターフェースを実現するための構造体、列挙定数、関数プロトタイプ宣言ファイル

+ `definition.c` :  
ClassFile構造体内のメソッド・フィールド・インターフェースを実装するための関数定義ファイル

+ `opcode.h` :  
OpcodeInfo構造体を中心とする、JVMのオペコードを生成するための構造体宣言ファイル

+ `opcode.c` :  
JVMのオペコード情報を保持した配列の実装ファイル

+ `classfile.h` :  
ClassFile構造体を中心とする、クラスファイルのメモリ内表現を生成するのための構造体、列挙型定数、関数プロトタイプの宣言ファイル

+ `generator.h` :  
ClassFile構造体のメンバを生成するための構造体、関数プロトタイプの宣言ファイル

+ `generator.c` :  
ClassFile構造体のメンバを生成するための関数実装ファイル

###emit/###
+ `emitter.h` :  
クラスファイルを生成するための関数プロトタイプ宣言ファイル

+ `emitter.c` :  
クラスファイルを生成するための関数実装ファイル

###./###
+ `main.c` :  
実際に各生成フェーズを実行するコンパイラのメインエントリポイント実装ファイル

+ `Fibonacci.desk` :  
フィボナッチ数列を求めるDeskのサンプルプログラム

+ `Factorial.desk` :  
階乗の値を求めるDeskのサンプルプログラム

##参考##
前橋和弥 (2009). プログラミング言語を作る. 東京:株式会社技術評論社  
Tim Lindholm/Frank Yellin/村上 雅章(訳) (2001). Java仮想マシン仕様 第2版. 東京:株式会社ピアソン・エデュケーション
